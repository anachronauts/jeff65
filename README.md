# jeff65

[![Build Status](https://travis-ci.org/jdpage/jeff65.svg?branch=master)](https://travis-ci.org/jdpage/jeff65)

*jeff65* is a compiler for the Commodore 64 and (perhaps in the future) other
6502-based computers. It is implemented in Python 3 and uses ca65 (part of cc65)
as its assembler, producing .prg files. If VICE is available, it can also
generate .d64 disk images.

**note:** this project is currently in its early stages. Features discussed below
are largely the product of wishful thinking and may change at any time.

*jeff65* handles three kinds of file:

  - files in *gold* syntax, an imperative systems language for 6502-series
    processors,
  - files in *blum* syntax, for annotating units written in assembly language,
  - 6502 assembly files, which can be linked into *jeff65* projects with
    little-to-no fuss.

Invocation:

    usage: ./bin/jeff65 [-h] input_file

    positional arguments:
      input_file  the file to compile

    optional arguments:
      -h, --help  show this help message and exit


## Licensing

The *jeff65* compiler itself is provided under the GPLv3 license; if you
distribute a modified version of the compiler, you must also make the source
code for your modified version available, as described in the license terms. A
copy of the GPLv3 license is included in `LICENSE.txt` in the source
distribution.

The standard library units and runtime library, whenever they get written, will
probably be provided either using the GPL with a linking exception, or under a
non-copyleft license.

Please note that cc65 and its runtime libraries are (at time of writing)
provided under the zlib license.


## Gold-syntax

Gold-syntax provides an imperative systems programming language for 6502-series
processors. Features of the processor are exposed in a friendly-but-powerful
way; it should be possible to understand what code will be generated by looking
directly at the source file.

Gold-syntax is not associated with the Gold parser framework.


### Token Info

These are the tokens needed to parse an expression (highest binding power first):

    numeric_literal[value], identifier[name], string_literal[value]
    punctuation_open_bracket["["], punctiation_close_bracket["]"]
    punctuation_open_paren["("], punctuation_close_paren[")"]
    /* TODO: pointer operators? */
    operator_bw_and["&&&", "bitand"]
    oeprator_bw_or["|||", "bitor"]
    operator_bw_xor["bitxor"]
    operator_bw_lshift["<<", "lshift"]
    operator_bw_rshift[">>", "rshift"]
    operator_div["/"], operator_mult["*"]
    operator_add["+"], operator_minus["-"]
    operator_equals["==", "equals"], operator_gt[">"], operator_lt["<"], operator_gte[">="], operator_lte["<="]
    operator_not["not"]
    operator_and["and"]
    operator_or["or"]

These are the other tokens we will have (unsorted):

    keyword_use["use"]
    keyword_isr["isr"]
    keyword_fun["fun"]
    /* keyword_struct["struct"] */
    keyword_let["let"]
    keyword_while["while"]
    keyword_for["for"]
    keyword_do["do"]
    keyword_end["end"]
    keyword_endfun["endfun"]
    keyword_endisr["endisr"]
    /* keyword_endstruct["endstruct"] */
    keyword_if["if"]
    keyword_elseif["elseif"]
    keyword_else["else"]
    keyword_then["then"]
    keyword_in["in"]
    keyword_mut["mut"]
    keyword_stash["stash"]
    keyword_byte["byte"]
    keyword_dword["dword"]
    keyword_qword["qword"]
    /* punctiation_open_brace["{"] */
    /* punctiation_close_brace["}"] */
    punctuation_colon[":"]
    operator_assign["="]
    comment[value]
    whitespace[value]
    eof


## Blum-syntax

Blum-syntax is used to annotate units written directly in assembly, and also as
an intermediate output by the compiler. Details forthcoming as we dream them up.
